# å³æ—¶è¡ŒåŠ¨è®¡åˆ’ï¼šfoobar2000 å…¼å®¹æ€§ç´§æ€¥ä¿®å¤

**åˆ›å»ºæ—¥æœŸ**: 2025-12-09
**ä¼˜å…ˆçº§**: URGENT
**å½“å‰å…¼å®¹æ€§è¯„çº§**: 15/100ï¼ˆä¸¥é‡ä¸å…¼å®¹ï¼‰

## æ‰§è¡Œæ‘˜è¦

åŸºäºæ·±åº¦æŠ€æœ¯åˆ†æï¼Œé¡¹ç›®å­˜åœ¨æ ¹æœ¬æ€§æ¶æ„ä¸å…¼å®¹é—®é¢˜ã€‚æœ¬è®¡åˆ’ä¸“æ³¨äºæœ€å…³é”®çš„ 5 ä¸ªä¿®å¤é¡¹ç›®ï¼Œé¢„è®¡å¯åœ¨ 4-6 å‘¨å†…æ˜¾è‘—æå‡å…¼å®¹æ€§è‡³ 45-55/100ï¼ˆéƒ¨åˆ†å¯ç”¨ï¼‰ã€‚

## ç°çŠ¶ï¼šå…³é”®æ•…éšœåˆ†æ

### å½“å‰ä»£ç åº“çš„å…¼å®¹æ€§ç¼ºé™·

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å·²å‘ç°çš„ä¸¥é‡é—®é¢˜ï¼ˆå¿…é¡»ç«‹å³ä¿®å¤ï¼‰                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âŒ é›¶ä¸ªé€‚é…å™¨å®ç°ï¼ˆä»… 32 ä¸ªå­˜æ ¹å’Œæ¥å£ï¼‰                   â”‚
â”‚ âŒ SDK æ¥å£æ˜¯ç©ºçš„å¤´æ–‡ä»¶ï¼ˆæ— ä»»ä½•å®ç°ï¼‰                     â”‚
â”‚ âŒ å…ƒæ•°æ®ç³»ç»Ÿï¼šåªæœ‰ç®€å•çš„é”®å€¼å¯¹ï¼Œæ— å¤šå€¼å­—æ®µ               â”‚
â”‚ âŒ æ— è„šæœ¬å¼•æ“ï¼ˆç”¨æˆ·æ— æ³•ä½¿ç”¨è‡ªå®šä¹‰æ ¼å¼ï¼‰                   â”‚
â”‚ âŒ æ’­æ”¾å¼•æ“ï¼šå•çº¿ç¨‹ï¼Œæ—  DSP é“¾                            â”‚
â”‚ âŒ é…ç½®ç³»ç»Ÿï¼šJSON ä¸ foobar2000 çš„å…¨å±€å˜é‡ä¸å…¼å®¹          â”‚
â”‚ âŒ æ— æ³•åŠ è½½ä»»ä½• foobar2000 DLLï¼ˆè°ƒç”¨çº¦å®šä¸åŒ¹é…ï¼‰         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## äº”å¤§å…³é”®ä¿®å¤é¡¹ç›®

### ğŸ”´ **ä¿®å¤ #1ï¼šå®ç°åŸºç¡€ SDK æ¥å£**ï¼ˆç¼ºå¤±ç‡ 100%ï¼‰

**çŠ¶æ€**ï¼šæœªå¼€å§‹  
**å½±å“**ï¼šé˜»å¡ - æ— æ³•åŠ è½½ä»»ä½•æ’ä»¶  
**é¢„è®¡æ—¶é—´**ï¼š1-2 å‘¨  
**å¤æ‚åº¦**ï¼šä¸­ç­‰

#### éœ€è¦å®ç°çš„æ¥å£

```cpp
// ============================================
// compat/sdk_implementations/service_base.cpp
// ============================================
#include "foobar_sdk/foobar2000_sdk.h"

// service_base å®ç°ï¼ˆæ‰€æœ‰æœåŠ¡çš„åŸºç±»ï¼‰
service_base::~service_base() = default;

void service_base::service_add_ref() {
    ++refcount_;
}

void service_base::service_release() {
    if (--refcount_ == 0) {
        delete this;
    }
}

// ============================================
// compat/sdk_implementations/abort_callback.cpp
// ============================================
class abort_callback_impl : public abort_callback {
private:
    std::atomic<bool> aborted_{false};
    mutable std::mutex mutex_;
    std::vector<std::function<bool()>> callbacks_;

public:
    bool is_aborting() const override {
        if (aborted_.load()) return true;
        
        std::lock_guard<std::mutex> lock(mutex_);
        for (const auto& cb : callbacks_) {
            if (cb()) {
                aborted_ = true;
                return true;
            }
        }
        return false;
    }
    
    void set() { aborted_ = true; }
};

// ============================================
// compat/sdk_implementations/audio_chunk.cpp
// ============================================
class audio_chunk_impl : public audio_chunk {
    pfc::array_t<audio_sample> data_;
    uint32_t sample_rate_ = 0;
    uint32_t channels_ = 0;
    uint64_t sample_count_ = 0;
    
public:
    audio_sample* get_data() override { return data_.get_ptr(); }
    const audio_sample* get_data() const override { return data_.get_ptr(); }
    uint32_t get_sample_count() const override { return sample_count_; }
    // ... æ›´å¤šæ–¹æ³• ...
};
```

#### ä»»åŠ¡æ¸…å•
- [ ] **å‘¨ä¸€**ï¼šåˆ›å»º `compat/sdk_implementations/` ç›®å½•ç»“æ„
- [ ] **å‘¨ä¸€**ï¼šå®ç° `service_base`ã€`abort_callback`ã€`audio_chunk`
- [ ] **å‘¨äºŒ**ï¼šå®ç° `file_info`ï¼ˆå…³é”®ï¼šå¤šå€¼å­—æ®µæ”¯æŒï¼‰
- [ ] **å‘¨ä¸‰**ï¼šå®ç° `audio_sample`ã€å†…å­˜ç®¡ç†å·¥å…·
- [ ] **å‘¨å››**ï¼šå®ç°å­—ç¬¦ä¸²å¤„ç†ï¼ˆ`pfc::string` ç­‰ï¼‰
- [ ] **å‘¨äº”**ï¼šæ¥å£æµ‹è¯•å’ŒéªŒè¯
- [ ] **ç¬¬äºŒå‘¨**ï¼šå®ç° `metadb_handle`ã€`metadb` å­˜æ ¹

#### å…³é”®ä»£ç ç¤ºä¾‹

```cpp
// compat/sdk_implementations/file_info_impl.h
#pragma once
#include "foobar_sdk/foobar2000_sdk.h"
#include <unordered_map>
#include <vector>

namespace foobar2000_sdk {

class file_info_impl : public file_info {
    // å…³é”®ï¼šæ”¯æŒå¤šå€¼å­—æ®µï¼Œå¦‚ tagger::["artist1", "artist2"]
    struct field_value {
        std::vector<std::string> values;
    };
    
    std::unordered_map<std::string, field_value> meta_fields_;
    audio_info_impl audio_info_;
    file_stats stats_;
    
public:
    // file_info æ¥å£å®ç°
    const char* meta_get(const char* p_name, size_t p_index) const override;
    size_t meta_get_count(const char* p_name) const override;
    bool meta_set(const char* p_name, const char* p_value) override;
    bool meta_remove(const char* p_name) override;
    bool meta_add(const char* p_name, const char* p_value) override;
    
    // éŸ³é¢‘ä¿¡æ¯
    void set_audio_info(const audio_info& info) override { audio_info_ = info; }
    const audio_info& get_audio_info() const override { return audio_info_; }
    
    // æ–‡ä»¶ç»Ÿè®¡
    void set_file_stats(const file_stats& stats) override { stats_ = stats; }
    const file_stats& get_file_stats() const override { return stats_; }
};

} // namespace foobar2000_sdk
```

---

### ğŸ”´ **ä¿®å¤ #2ï¼šåˆ›å»ºå¯åŠ è½½ foobar2000 DLL çš„æ’ä»¶åŠ è½½å™¨**ï¼ˆç¼ºå¤±ç‡ 100%ï¼‰

**çŠ¶æ€**ï¼šæœªå¼€å§‹  
**å½±å“**ï¼šé˜»å¡ - æ’ä»¶æ— æ³•åŠ è½½  
**é¢„è®¡æ—¶é—´**ï¼š2-3 å‘¨  
**å¤æ‚åº¦**ï¼šé«˜ï¼ˆæ¶‰åŠå¤æ‚çš„æ¥å£è±å½¢ç»§æ‰¿é—®é¢˜ï¼‰

#### æ¶æ„

```cpp
// ============================================
// compat/plugin_loader/plugin_loader.h
// ============================================
class FoobarPluginLoader {
public:
    struct LoadedModule {
        void* handle = nullptr;
        std::vector<service_factory_base*> service_factories;
        std::string path;
        bool initialized = false;
    };
    
    Result load_plugin(const char* dll_path);
    void unload_plugin(const char* dll_path);
    
private:
    // è§£æ foobar2000 çš„å¯¼å‡ºå‡½æ•°
    Result parse_service_entries(LoadedModule& module);
    
    // å¯¹äºæ¯ä¸ªæœåŠ¡å·¥å‚ï¼Œæ³¨å†Œåˆ°æœåŠ¡æ³¨å†Œè¡¨
    Result register_services(LoadedModule& module);
    
    std::vector<LoadedModule> modules_;
    std::mutex mutex_;
};

// ============================================
// compat/plugin_loader/service_factory_adapter.h
// ============================================
// æ¡¥æ¥ foobar2000 æœåŠ¡å·¥å‚åˆ°æˆ‘ä»¬çš„æ’ä»¶ç³»ç»Ÿ
class ServiceFactoryAdapter : public service_factory_base {
    service_factory_base* foobar_factory;
    
public:
    service_factory_adapter(service_factory_base* foobar_factory)
        : foobar_factory(foobar_factory) {}
    
    service_ptr create_service() override {
        // ä» foobar2000 æ’ä»¶åˆ›å»ºæœåŠ¡å®ä¾‹
        return foobar_factory->create_service();
    }
    
    const GUID& get_guid() const override {
        return foobar_factory->get_guid();
    }
};
```

#### åŠ è½½æµç¨‹

```text
1. LoadLibrary("foo_input_flac.dll")
   â†“
2. GetProcAddress("_foobar2000_client_entry")
   â†“
3. è·å–æœåŠ¡å·¥å‚åˆ—è¡¨
   â†“
4. å¯¹æ¯ä¸ªæœåŠ¡å·¥å‚ï¼š
   - åŒ…è£…ä¸ºæœ¬æœº ServiceFactoryAdapter
   - æ³¨å†Œåˆ° ServiceRegistry
   â†“
5. å½“è¯·æ±‚æœåŠ¡æ—¶ï¼š
   - æŸ¥è¯¢é€‚é…å™¨
   - å§”æ‰˜ç»™ foobar2000 æœåŠ¡å·¥å‚
   - è¿”å›åŒ…è£…åçš„å®ä¾‹
```

#### ä»»åŠ¡æ¸…å•
- [ ] **Week 1**:
  - [ ] å®ç° Windows DLL åŠ è½½ï¼ˆLoadLibrary, GetProcAddressï¼‰
  - [ ] è§£æ foobar2000 æœåŠ¡æ¡ç›®æ ¼å¼
  - [ ] åˆ›å»º ServiceFactoryAdapter
  - [ ] åŸºç¡€é”™è¯¯å¤„ç†ï¼ˆDLL ç¼ºå¤±ã€å¯¼å‡ºç¬¦å·ç¼ºå¤±ï¼‰
  
- [ ] **Week 2**:
  - [ ] æµ‹è¯•ç”¨ foo_input_std.dllï¼ˆfoobar2000 å†…ç½®ç»„ä»¶ï¼‰
  - [ ] éªŒè¯æœåŠ¡åˆ›å»ºæµç¨‹
  - [ ] å®ç°å¸è½½æœºåˆ¶ï¼ˆå¼•ç”¨è®¡æ•°å½’é›¶æ—¶ FreeLibraryï¼‰
  - [ ] é›†æˆåˆ°ç°æœ‰çš„ PluginHost
  
- [ ] **Week 3**:
  - [ ] æµ‹è¯•ç¬¬ä¸‰æ–¹æ’ä»¶ï¼ˆfoo_input_flac, foo_dsp_eq ç­‰ï¼‰
  - [ ] è°ƒè¯•è°ƒç”¨çº¦å®šé—®é¢˜ï¼ˆ__thiscall vs __stdcallï¼‰
  - [ ] ä¿®å¤ vtable å¸ƒå±€ä¸å…¼å®¹

#### å·²çŸ¥æŠ€æœ¯æŒ‘æˆ˜

1. **è°ƒç”¨çº¦å®šä¸åŒ¹é…**
   - foobar2000ï¼šé€šå¸¸ä½¿ç”¨ `__thiscall`ï¼ˆæˆå‘˜å‡½æ•°ï¼‰
   - éœ€è¦éªŒè¯ vtable å¸ƒå±€å®Œå…¨ä¸€è‡´
   - å¯èƒ½éœ€è¦ thunk æˆ– trampoline ä»£ç 

2. **æ¥å£è±å½¢ç»§æ‰¿**
   - foobar2000 æœåŠ¡é€šå¸¸ä»å¤šä¸ªæ¥å£ç»§æ‰¿
   - éœ€è¦ç¡®ä¿ dynamic_cast åœ¨ DLL è¾¹ç•Œå·¥ä½œ
   - å¯èƒ½éœ€è¦ RTTI å…¼å®¹æ€§å±‚

3. **å…¨å±€çŠ¶æ€å†²çª**
   - foobar2000 æ’ä»¶å¯èƒ½ä½¿ç”¨å…¨å±€/é™æ€å˜é‡
   - å¯èƒ½ä¸æ’­æ”¾å™¨æ ¸å¿ƒå†²çª
   - éœ€è¦åœ¨éš”ç¦»çš„ç¯å¢ƒä¸­åŠ è½½ï¼Ÿ

---

### ğŸ”´ **ä¿®å¤ #3ï¼šå…ƒæ•°æ®ç³»ç»Ÿç´§æ€¥å¢å¼º**ï¼ˆä¸å…¼å®¹ç‡ 100%ï¼‰

**çŠ¶æ€**ï¼šéƒ¨åˆ†å®ç°  
**å½±å“**ï¼šä¸¥é‡ - å…ƒæ•°æ®æ— æ³•æ­£ç¡®è¯»å–æˆ–æ˜¾ç¤º  
**é¢„è®¡æ—¶é—´**ï¼š2-3 å‘¨  
**å¤æ‚åº¦**ï¼šä¸­ç­‰

#### é—®é¢˜åˆ†æ

```cpp
// å½“å‰é¡¹ç›®çš„å…ƒæ•°æ®ï¼ˆä»…ç®€å•é”®å€¼å¯¹ï¼‰
struct MetadataTag {
    const char* key;      // "artist"
    const char* value;    // "The Beatles"
};

// foobar2000 çš„å…ƒæ•°æ®ï¼ˆå¤šå€¼å­—æ®µï¼‰
class file_info {
    // å¯ä»¥åŒ…å«å¤šä¸ªå€¼ï¼š
    // tagger::["artist1", "artist2", "artist3"]
    // genre::["rock", "classic rock"]
    // 
    // ç‰¹æ®Šå­—æ®µï¼š
    // %play_count% <å†…ç½®ç»Ÿè®¡>
    // %last_played% <å†…ç½®ç»Ÿè®¡>
    // %rating% <ç”¨æˆ·è¯„åˆ†>
};
```

#### åˆ†é˜¶æ®µå¢å¼º

**é˜¶æ®µ 1ï¼šå¤šå€¼å­—æ®µæ”¯æŒï¼ˆWeek 1ï¼‰**

```cpp
// core/metadata/enhanced_metadata.h
class EnhancedMetadata {
public:
    struct Field {
        std::string name;
        std::vector<std::string> values;  // å¤šå€¼ï¼
        bool is_multi_value = false;
    };
    
    // è®¾ç½®å­—æ®µå€¼ï¼ˆå•å€¼æˆ–å¤šå€¼ï¼‰
    void set_field(const std::string& name, const std::string& value);
    void set_field(const std::string& name, const std::vector<std::string>& values);
    
    // è·å–å­—æ®µå€¼
    std::vector<std::string> get_field(const std::string& name) const;
    std::string get_field_first(const std::string& name) const;
    
    // æ£€æŸ¥å­—æ®µæ˜¯å¦å­˜åœ¨ä¸”æœ‰å€¼
    bool has_field(const std::string& name) const;
    
private:
    std::unordered_map<std::string, Field> fields_;
};

// ä½¿ç”¨ç¤ºä¾‹
EnhancedMetadata meta;
meta.set_field("artist", std::vector<std::string>{"The Beatles", "Paul McCartney"});
meta.set_field("genre", std::vector<std::string>{"rock", "classic rock"});

auto artists = meta.get_field("artist");  // è¿”å› ["The Beatles", "Paul McCartney"]
```

**é˜¶æ®µ 2ï¼šç»Ÿè®¡ä¿¡æ¯ï¼ˆPlay Count, Last Playedï¼‰ï¼ˆWeek 2ï¼‰**

```cpp
// core/metadata/track_statistics.h
struct TrackStatistics {
    uint32_t play_count = 0;
    uint64_t first_played_timestamp = 0;  // Unix timestamp
    uint64_t last_played_timestamp = 0;
    uint64_t added_timestamp = 0;
    
    float rating = 0.0f;  // 0-5 æ˜Ÿ
    uint32_t skip_count = 0;
    
    // æŒä¹…åŒ–åˆ° metadb
    void save(const std::string& track_identifier);
    void load(const std::string& track_identifier);
};

// é›†æˆåˆ°ç°æœ‰ TrackInfo
struct EnhancedTrackInfo {
    std::string file_path;
    EnhancedMetadata metadata;
    TrackStatistics stats;
    // ... å…¶ä»–å­—æ®µ
};
```

**é˜¶æ®µ 3ï¼šæŸ¥è¯¢å¼•æ“ï¼ˆWeek 3ï¼‰**

```cpp
// compat/metadata/query_engine.h
class MetadataQueryEngine {
public:
    // ç®€å•çš„æŸ¥è¯¢è¯„ä¼°
    bool evaluate(const std::string& query, const EnhancedTrackInfo& track);
    
private:
    // åŸºç¡€è§£æå™¨ï¼ˆæ”¯æŒç®€å•æŸ¥è¯¢ï¼‰
    bool parse_and_evaluate(const std::string& query, 
                           const EnhancedTrackInfo& track);
    
    // æ”¯æŒçš„æ“ä½œç¬¦
    enum Operator { IS, IS_NOT, GREATER, LESS, AFTER, BEFORE, HAS };
};
```

#### ä¸ foobar2000 æ ¼å¼çš„å…¼å®¹

```cpp
// compat/metadata/metadb_adapter.h
class MetadbAdapter {
public:
    // ä» EnhancedMetadata åˆ›å»º file_infoï¼ˆä¾› foobar2000 æ’ä»¶ä½¿ç”¨ï¼‰
    static std::unique_ptr<file_info_impl> to_file_info(
        const EnhancedTrackInfo& track);
    
    // ä» foobar2000 file_info æ›´æ–° EnhancedMetadata
    static void from_file_info(EnhancedTrackInfo& track, 
                               const file_info& info);
};
```

#### ä»»åŠ¡æ¸…å•
- [ ] **Week 1**ï¼šEnhancedMetadata ç±»å’Œå¤šå€¼å­—æ®µ
- [ ] **Week 1**ï¼šæ›´æ–° FLAC è§£ç å™¨ä»¥å¡«å……å¤šå€¼å­—æ®µ
- [ ] **Week 2**ï¼šTrackStatistics å®ç°
- [ ] **Week 2**ï¼šæŒä¹…åŒ–å±‚ï¼ˆSQLiteï¼‰
- [ ] **Week 3**ï¼šåŸºç¡€æŸ¥è¯¢å¼•æ“ï¼ˆIS, AND, ORï¼‰
- [ ] **Week 3**ï¼šé›†æˆæµ‹è¯•

---

### ğŸŸ¡ **ä¿®å¤ #4ï¼šTitleformat è„šæœ¬å¼•æ“ - æ ¸å¿ƒå®ç°**ï¼ˆç¼ºå¤±ç‡ 100%ï¼‰

**çŠ¶æ€**ï¼šæœªå¼€å§‹  
**å½±å“**ï¼šä¸¥é‡ - UI è‡ªå®šä¹‰å®Œå…¨å¤±æ•ˆ  
**é¢„è®¡æ—¶é—´**ï¼š3-4 å‘¨  
**å¤æ‚åº¦**ï¼šé«˜

#### æœ€å°å¯è¡Œå®ç°ï¼ˆæ”¯æŒ 80% çš„å¸¸ç”¨åŠŸèƒ½ï¼‰

æ”¯æŒçš„æ“ä½œç¬¦å’Œå‡½æ•°ï¼š
```
åŸºæœ¬å­—æ®µ: %artist%, %title%, %album%, %tracknumber%
æ¡ä»¶: $if(cond, true, false)
æ¡ä»¶ç®€å†™: [text] (ä»…å½“å­—æ®µå­˜åœ¨æ—¶æ˜¾ç¤º)
å‡½æ•°: $len(), $lower(), $upper(), $pad()
æ‹¬å·: (expression)
```

#### æ¶æ„

```cpp
// compat/scripting/titleformat_compiler.h
class TitleformatCompiler {
public:
    // ç¼–è¯‘è„šæœ¬ä¸ºä¸­é—´è¡¨ç¤º
    Result compile(const std::string& script);
    
    // æ‰§è¡Œå·²ç¼–è¯‘çš„è„šæœ¬
    std::string execute(const EnhancedTrackInfo& track);
    
private:
    enum class OpCode {
        PUSH_FIELD,      // å‹å…¥å­—æ®µå€¼ï¼ˆä» track.metadataï¼‰
        PUSH_LITERAL,    // å‹å…¥å­—é¢å€¼
        CONDITIONAL,     // æ¡ä»¶ ?: æ“ä½œç¬¦
        FUNCTION_CALL,   // å‡½æ•°è°ƒç”¨
        CONCAT,          // éšå¼è¿æ¥
    };
    
    struct Instruction {
        OpCode opcode;
        std::string operand;  // å­—æ®µåã€å­—é¢å€¼æˆ–å‡½æ•°å
        std::vector<Instruction> children;  // ç”¨äºåµŒå¥—è¡¨è¾¾å¼
    };
    
    std::vector<Instruction> program_;
    
    // è¯æ³•åˆ†æ
    Result tokenize(const std::string& script, std::vector<Token>& tokens);
    
    // è¯­æ³•åˆ†æ
    Result parse(const std::vector<Token>& tokens);
};

// compat/scripting/functions.h
class BuiltinFunctions {
public:
    static std::string if_func(const std::vector<std::string>& args);
    static std::string len_func(const std::vector<std::string>& args);
    static std::string lower_func(const std::vector<std::string>& args);
    static std::string upper_func(const std::vector<std::string>& args);
    static std::string pad_func(const std::vector<std::string>& args);
};
```

#### ç®€åŒ–æ‰§è¡Œç¤ºä¾‹

```cpp
// è„šæœ¬ï¼š%artist% - %title% '['%bitrate% kbps']'
// ç¼–è¯‘ä¸ºï¼š
// PUSH_FIELD "artist"
// PUSH_LITERAL " - "
// PUSH_FIELD "title"
// CONCAT (3 values)
// PUSH_LITERAL " ["
// PUSH_FIELD "bitrate"
// PUSH_LITERAL " kbps]"
// CONCAT (3 values)
// CONDITIONAL (if bitrate exists, include bracket part)
// CONCAT (final string)

std::string TitleformatCompiler::execute(const EnhancedTrackInfo& track) {
    std::stack<std::string> stack;
    
    for (const auto& instr : program_) {
        switch (instr.opcode) {
            case OpCode::PUSH_FIELD: {
                auto values = track.metadata.get_field(instr.operand);
                stack.push(values.empty() ? "" : values[0]);
                break;
            }
            case OpCode::PUSH_LITERAL:
                stack.push(instr.operand);
                break;
            case OpCode::CONCAT: {
                std::string result;
                // ä»æ ˆä¸­å¼¹å‡ºå¤šä¸ªå€¼å¹¶è¿æ¥
                int count = std::stoi(instr.operand);
                std::vector<std::string> parts;
                for (int i = 0; i < count; ++i) {
                    parts.push_back(stack.top());
                    stack.pop();
                }
                // é€†åºè¿æ¥ï¼ˆæ ˆæ˜¯åè¿›å…ˆå‡ºï¼‰
                for (auto it = parts.rbegin(); it != parts.rend(); ++it) {
                    result += *it;
                }
                stack.push(result);
                break;
            }
            case OpCode::CONDITIONAL: {
                std::string false_part = stack.top(); stack.pop();
                std::string true_part = stack.top(); stack.pop();
                std::string cond = stack.top(); stack.pop();
                stack.push(cond.empty() ? false_part : true_part);
                break;
            }
        }
    }
    
    return stack.empty() ? "" : stack.top();
}
```

#### ä»»åŠ¡æ¸…å•
- [ ] **Week 1**ï¼šè¯æ³•åˆ†æå™¨ï¼ˆè¯†åˆ« %field%, $func(), []ï¼‰
- [ ] **Week 2**ï¼šè¯­æ³•æ ‘æ„å»ºå’ŒåŸºç¡€æ‰§è¡Œï¼ˆå­—æ®µæ›¿æ¢ï¼‰
- [ ] **Week 3**ï¼šæ¡ä»¶è¯­å¥ï¼ˆ$if, []ï¼‰å’Œå†…ç½®å‡½æ•°
- [ ] **Week 4**ï¼šUI é›†æˆå’Œæµ‹è¯•å¥—ä»¶

---

### ğŸŸ¡ **ä¿®å¤ #5ï¼šéŸ³é¢‘ç®¡é“ - DSP å’Œ ReplayGain åŸºç¡€**ï¼ˆç¼ºå¤±ç‡ 80%ï¼‰

**çŠ¶æ€**ï¼šéƒ¨åˆ† DSP æœ‰å­˜æ ¹  
**å½±å“**ï¼šä¸­ç­‰ - éŸ³é¢‘è´¨é‡å—å½±å“  
**é¢„è®¡æ—¶é—´**ï¼š2-3 å‘¨  
**å¤æ‚åº¦**ï¼šä¸­ç­‰åˆ°é«˜

#### å½“å‰çŠ¶æ€

```cpp
// plugins/dsp/volume_control_dsp.cpp æ˜¯ç©ºçš„å­˜æ ¹ï¼
// éœ€è¦å®ç°å®é™…çš„éŸ³é‡æ§åˆ¶
```

#### DSP é“¾æ¶æ„

```cpp
// compat/audio/dsp_chain_manager.h
class DSPChainManager {
public:
    // æ·»åŠ  DSP å¤„ç†å™¨åˆ°é“¾
    void add_dsp(std::unique_ptr<dsp> processor);
    
    // å¤„ç†éŸ³é¢‘å—
    void process(audio_chunk& chunk, abort_callback& abort);
    
    // é…ç½®ç®¡ç†
    void load_config(const std::string& config);
    std::string save_config() const;
    
private:
    std::vector<std::unique_ptr<dsp>> dsp_chain_;
    std::mutex mutex_;
};

// compat/audio/replaygain_processor.h
class ReplayGainProcessor {
public:
    struct Settings {
        enum Mode { DISABLED, TRACK, ALBUM, SMART };
        Mode mode = TRACK;
        float preamp_db = 0.0f;  // å‰ç½®æ”¾å¤§ï¼ˆdBï¼‰
        bool prevent_clipping = true;
    };
    
    // ä» metadb è¯»å– RG ä¿¡æ¯å¹¶åº”ç”¨å¢ç›Š
    void apply_gain(audio_chunk& chunk, const EnhancedTrackInfo& track);
    
private:
    Settings settings_;
    
    float calculate_gain(const TrackStatistics& stats) const;
    void apply_gain_to_chunk(audio_chunk& chunk, float gain_db);
};
```

#### å…·ä½“ DSP å®ç°

```cpp
// compat/audio/dsp/volume_control.cpp
class VolumeControlDSP : public dsp {
    float volume_linear_ = 1.0f;  // 0.0 to 1.0
    float volume_db_ = 0.0f;      // dB
    
public:
    void run(audio_chunk* chunk, abort_callback& abort) override {
        audio_sample* data = chunk->get_data();
        size_t samples = chunk->get_sample_count() * chunk->get_channels();
        
        for (size_t i = 0; i < samples; ++i) {
            data[i] *= volume_linear_;
        }
    }
    
    void set_volume(float db) {
        volume_db_ = db;
        volume_linear_ = powf(10.0f, db / 20.0f);
    }
};

// compat/audio/dsp/equalizer.cpp
class EqualizerDSP : public dsp {
    // ç®€å• 10 æ®µ EQ
    static constexpr size_t BANDS = 10;
    float gains_db_[BANDS] = {0.0f};
    
    // æ»¤æ³¢å™¨ç³»æ•°ï¼ˆç®€åŒ–ï¼‰
    struct Filter {
        float freq;
        float q;
        float gain_db;
    } filters_[BANDS];
    
public:
    void run(audio_chunk* chunk, abort_callback& abort) override {
        // åº”ç”¨æ¯ä¸ªé¢‘æ®µçš„å¢ç›Š
        // å®é™…å®ç°éœ€è¦åŒäºŒé˜¶æ»¤æ³¢å™¨
    }
};
```

#### é›†æˆåˆ°æ’­æ”¾å¼•æ“

```cpp
// ä¿®æ”¹ core/playback_engine.cpp
Result PlaybackEngine::initialize(IAudioOutput* audio_output) {
    // ç°æœ‰ä»£ç ...
    
    // åˆå§‹åŒ– DSP é“¾
    dsp_chain_manager_ = std::make_unique<DSPChainManager>();
    replaygain_processor_ = std::make_unique<ReplayGainProcessor>();
    
    // åŠ è½½é…ç½®
    dsp_chain_manager_->load_config(config_->get_string("dsp", "chain", ""));
    
    return Result::Success;
}

void PlaybackEngine::audio_callback(void* buffer, size_t frames, void* user_data) {
    // ç°æœ‰è§£ç é€»è¾‘...
    
    // åˆ›å»º audio_chunk åŒ…è£…è§£ç æ•°æ®
    audio_chunk_impl chunk;
    chunk.set_data((audio_sample*)buffer, frames, channels, sample_rate);
    
    // åº”ç”¨ ReplayGain
    if (replaygain_processor_) {
        replaygain_processor_->apply_gain(chunk, current_track_);
    }
    
    // é€šè¿‡ DSP é“¾å¤„ç†
    if (dsp_chain_manager_) {
        abort_callback_impl abort;
        dsp_chain_manager_->process(chunk, abort);
    }
    
    // ç»§ç»­æ’­æ”¾...
}
```

#### ä»»åŠ¡æ¸…å•
- [ ] **Week 1**: DSP é“¾åŸºç¡€æ¶æ„å’Œ VolumeControlDSP
- [ ] **Week 1**: ReplayGain ä¿¡æ¯è¯»å–å’Œåº”ç”¨
- [ ] **Week 2**: Equalizer DSPï¼ˆåŸºç¡€ç‰ˆæœ¬ï¼‰
- [ ] **Week 2**: é…ç½®ç®¡ç†ï¼ˆä¿å­˜/åŠ è½½ DSP é“¾è®¾ç½®ï¼‰
- [ ] **Week 3**: æ€§èƒ½ä¼˜åŒ–å’Œä½å»¶è¿Ÿå¤„ç†
- [ ] **Week 3**: é›†æˆæµ‹è¯•

---

## å¿«é€Ÿèƒœåˆ©ï¼šç«‹å³å¯å®æ–½çš„ä½æ‚¬æœå®

è¿™äº›ä»»åŠ¡å¯åœ¨ 1-2 å¤©å†…å®Œæˆï¼Œèƒ½ç«‹å³æ”¹å–„ç”¨æˆ·ä½“éªŒï¼š

### 1. æ›´æ–°æ–‡æ¡£ï¼Œè¯šå®è¯´æ˜å½“å‰é™åˆ¶

```markdown
# README.md - åœ¨ "Features" ç« èŠ‚æ·»åŠ 

## âš ï¸ å…¼å®¹æ€§çŠ¶æ€ï¼šéƒ¨åˆ†å¯ç”¨

**å½“å‰ foobar2000 å…¼å®¹æ€§è¯„çº§ï¼š15/100**

| åŠŸèƒ½ | å…¼å®¹æ€§ | é¢„ä¼°å®Œæˆæ—¶é—´ |
|------|--------|-------------|
| åŠ è½½ foobar2000 æ’ä»¶ | âŒ æœªå®ç° | 4-6 å‘¨ |
| å¤æ‚å…ƒæ•°æ®æŸ¥è¯¢ | âŒ ä¸æ”¯æŒ | 2-3 å‘¨ |
| Titleformat è„šæœ¬ | âŒ ç¼ºå¤± | 3-4 å‘¨ |
| ReplayGain æ”¯æŒ | âŒ æœªå®ç° | 2 å‘¨ |
| DSP é“¾ | âŒ éƒ¨åˆ† | 2-3 å‘¨ |
| æ’­æ”¾åˆ—è¡¨è¿ç§» | âŒ ä¸é€‚ç”¨ | å¾…è°ƒæŸ¥ |

**æˆ‘ä»¬ç›®å‰æ­£åœ¨ç§¯æå®æ–½è¿™äº›åŠŸèƒ½ã€‚æŸ¥çœ‹ [COMPATIBILITY_RECOVERY_PLAN.md] äº†è§£è¯¦æƒ…ã€‚**
```

### 2. åœ¨ CMake ä¸­æ·»åŠ æ˜ç¡®çš„è­¦å‘Š

```cmake
# CMakeLists.txt
if(ENABLE_FOOBAR_COMPAT)
    message(WARNING "
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    âš ï¸  foobar2000 å…¼å®¹æ€§è­¦å‘Š
    
    å½“å‰å…¼å®¹æ€§å±‚ä»…åŒ…å«æ¥å£å­˜æ ¹ï¼Œ
    æ— æ³•å®é™…åŠ è½½ foobar2000 æ’ä»¶ã€‚
    
    å®Œæ•´å®ç°é¢„è®¡éœ€è¦ 4-6 ä¸ªæœˆã€‚
    æŸ¥çœ‹ COMPATIBILITY_RECOVERY_PLAN.md äº†è§£è¯¦æƒ…ã€‚
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ")
endif()
```

### 3. åœ¨å¯åŠ¨æ—¶æ˜¾ç¤ºå…¼å®¹æ€§çŠ¶æ€

```cpp
// src/main.cpp
int main() {
    // ...
    
#ifdef ENABLE_FOOBAR_COMPAT
    std::cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << std::endl;
    std::cout << "foobar2000 Compatibility Layer Status:" << std::endl;
    std::cout << "  SDK Interfaces: " << (AreSDKInterfacesImplemented() ? "âœ…" : "âŒ") << std::endl;
    std::cout << "  Plugin Loader: " << (IsPluginLoaderImplemented() ? "âœ…" : "âŒ") << std::endl;
    std::cout << "  Metadata Support: " << (IsEnhancedMetadataEnabled() ? "âœ…" : "âŒ") << std::endl;
    std::cout << "  Titleformat Script: " << (IsTitleformatEnabled() ? "âœ…" : "âŒ") << std::endl;
    std::cout << "  DSP/RG: " << (IsDSPChainEnabled() ? "âœ…" : "âŒ") << std::endl;
    std::cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << std::endl;
#endif
    
    // ...
}
```

---

## å·¥ä½œè®¡åˆ’æ—¶é—´è¡¨

### ç¬¬ 1-2 å‘¨ï¼šåŸºç¡€ SDK å’ŒåŠ è½½å™¨
```
Week 1:
  Mon: sdk_implementations/ ç›®å½• + service_base + abort_callback
  Tue: file_info (å…³é”®ï¼å¤šå€¼å­—æ®µ) + audio_chunk
  Wed: å­—ç¬¦ä¸²å·¥å…· + audio_info
  Thu: plugin_loader/ åŸºç¡€æ¶æ„
  Fri: DLL åŠ è½½å‡½æ•° + æœåŠ¡å·¥å‚è§£æ

Week 2:
  Mon: æœåŠ¡æ³¨å†Œé€‚é…å™¨
  Tue: æµ‹è¯•ç”¨ foo_input_std.dll åŠ è½½
  Wed: è§£å†³é“¾æ¥é”™è¯¯å’Œ vtable é—®é¢˜
  Thu: é”™è¯¯å¤„ç† + æ–‡æ¡£
  Fri: ä»£ç å®¡æŸ¥ + åˆå¹¶
```

### ç¬¬ 3-4 å‘¨ï¼šå…ƒæ•°æ®å¢å¼º
```
Week 3:
  Mon/Tue: EnhancedMetadata ç±»ï¼ˆå¤šå€¼å­—æ®µï¼‰
  Wed/Thu: FLAC è§£ç å™¨æ›´æ–° + stats å®ç°
  Fri: æŒä¹…åŒ–å±‚è®¾è®¡

Week 4:
  Mon/Tue: SQLite é›†æˆ + åŸºç¡€æŸ¥è¯¢
  Wed/Thu: æŸ¥è¯¢è§£æå™¨ï¼ˆIS, AND, ORï¼‰
  Fri: é›†æˆæµ‹è¯•
```

### ç¬¬ 5-6 å‘¨ï¼šè„šæœ¬å’ŒéŸ³é¢‘
```
Week 5:
  Mon/Tue: Titleformat è¯æ³•åˆ†æ
  Wed/Thu: è¯­æ³•æ ‘ + å­—æ®µæ›¿æ¢
  Fri: æ¡ä»¶è¡¨è¾¾å¼

Week 6:
  Mon/Tue: DSP é“¾æ¶æ„ + VolumeControl
  Wed/Thu: ReplayGain å®ç°
  Fri: é›†æˆæµ‹è¯• + æ–‡æ¡£æ›´æ–°
```

### ç¬¬ 7-8 å‘¨ï¼šç¡¬åŒ–å’Œæµ‹è¯•
```
Week 7:
  Mon/Tue: æµ‹è¯•å¥—ä»¶æ‰©å±•
  Wed/Thu: Bug ä¿®å¤
  Fri: æ€§èƒ½ä¼˜åŒ–

Week 8:
  Mon/Tue: æ–‡æ¡£å®Œå–„
  Wed/Thu: ç”¨æˆ·åé¦ˆæ”¶é›†
  Fri: å°ç‰ˆæœ¬å‘å¸ƒ
```

---

## èµ„æºåˆ†é…å»ºè®®

### æœ€å°å¯è¡Œå›¢é˜Ÿï¼ˆ4 äººï¼‰

1. **å·¥ç¨‹å¸ˆ A**ï¼šSDK æ¥å£å’ŒåŠ è½½å™¨ï¼ˆæ ¸å¿ƒï¼‰
2. **å·¥ç¨‹å¸ˆ B**ï¼šå…ƒæ•°æ®å’ŒæŸ¥è¯¢å¼•æ“
3. **å·¥ç¨‹å¸ˆ C**ï¼šTitleformat è„šæœ¬å¼•æ“
4. **å·¥ç¨‹å¸ˆ D**ï¼šéŸ³é¢‘ç®¡é“ + é›†æˆæµ‹è¯•

### éœ€è¦çš„æŠ€èƒ½

- **C++17**: å¿…é¡»ç²¾é€šæ¨¡æ¿å…ƒç¼–ç¨‹å’Œ ABI
- **Win32 API**: DLL åŠ è½½ã€COM æ¥å£ã€çº¿ç¨‹æ¨¡å‹
- **éŸ³é¢‘å¤„ç†**: DSPã€æ•°å­—ä¿¡å·å¤„ç†åŸºç¡€
- **è§£æå™¨ç¼–å†™**: é€’å½’ä¸‹é™ã€LALR ç­‰
- **SQLite**: ç”¨äºå…ƒæ•°æ®å­˜å‚¨

---

## æˆåŠŸæŒ‡æ ‡

### çŸ­æœŸï¼ˆ8 å‘¨åï¼‰
- [ ] è‡³å°‘ 1 ä¸ª foobar2000 æ’ä»¶å¯åŠ è½½å¹¶å·¥ä½œ
- [ ] å¤šå€¼å­—æ®µå…ƒæ•°æ®æ­£ç¡®æ˜¾ç¤º
- [ ] ç®€å• Titleformat è„šæœ¬ï¼ˆ%artist% - %title%ï¼‰å·¥ä½œ
- [ ] ReplayGain åº”ç”¨åŸºæœ¬å¢ç›Š
- [ ] å…¼å®¹æ€§è¯„çº§ï¼š45-55/100

### é•¿æœŸï¼ˆ6 ä¸ªæœˆåï¼‰
- [ ] 80% çš„å¸¸ç”¨ foobar2000 æ’ä»¶å·¥ä½œ
- [ ] å¤æ‚æŸ¥è¯¢è¯­æ³•ï¼ˆ%album artist% IS X AND %date% AFTER Yï¼‰
- [ ] å®Œæ•´ Titleformat åŠŸèƒ½ï¼ˆæ‰€æœ‰å‡½æ•°å’Œæ“ä½œç¬¦ï¼‰
- [ ] ç¨³å®šçš„ DSP é“¾ï¼ˆEQã€é‡é‡‡æ ·ç­‰ï¼‰
- [ ] å…¼å®¹æ€§è¯„çº§ï¼šâ‰¥80/100

---

## é™„å½•ï¼šç´§æ€¥è”ç³»äºº

```
æŠ€æœ¯è´Ÿè´£äºº: [TBD]
é¡¹ç›®ç®¡ç†å‘˜: [TBD]

æ¯æ—¥ç«™ä¼šæ—¶é—´: 09:00 UTC
æ¯å‘¨ä»£ç å®¡æŸ¥: å‘¨äº” 15:00 UTC
```

### ç›¸å…³èµ„æº
- [Foobar2000 SDK](https://wiki.hydrogenaud.io/index.php?title=Foobar2000_SDK)
- [å½“å‰æ¶æ„æ–‡æ¡£](.qoder/quests/music-player-development.md)
- [å®Œæ•´ä¿®å¤è®¡åˆ’](COMPATIBILITY_RECOVERY_PLAN.md)

### æœ¯è¯­è¡¨

- **Titleformat**ï¼šfoobar2000 çš„å£°æ˜å¼è„šæœ¬è¯­è¨€ï¼Œç”¨äºæ ¼å¼åŒ–æ˜¾ç¤ºå­—ç¬¦ä¸²
- **Metadb**ï¼šfoobar2000 çš„å…ƒæ•°æ®åº“ï¼Œæ”¯æŒå¤æ‚æŸ¥è¯¢å’Œç»Ÿè®¡
- **Service**ï¼šfoobar2000 çš„æ’ä»¶æ¥å£æ¨¡å¼ï¼Œç±»ä¼¼ COM
- **DSP**ï¼šæ•°å­—ä¿¡å·å¤„ç†
- **ReplayGain**ï¼šæ ‡å‡†åŒ–éŸ³é¢‘æ–‡ä»¶å“åº¦çš„æ ‡å‡†

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-12-09
**ä½œè€…**: æŠ€æœ¯æ¶æ„å›¢é˜Ÿ
**çŠ¶æ€**: ç´§æ€¥æ‰§è¡Œ
